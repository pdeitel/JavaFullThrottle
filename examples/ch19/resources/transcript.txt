Welcome to the What's New in Java lesson. In this lesson I have about two and a half hours of new video with new examples that will be appearing in our forthcoming new editions of our Java suite of products, and that includes the new edition of this video course, Java Fundamentals third edition. Java had a program 12th Edition, our Java textbook, and Java for programmers 5th Edition, our corresponding professional book as well. Throughout these videos, I'll be presenting various key Java programming features from Java 10 through Java 22, and I'll have a slide on one Java 23 feature as well that's related to some of the other examples that I'll be presenting to you here. These videos in the What's New Lesson are targeted to existing lessons in the current product where the features in question could potentially be used. That does not necessarily reflect where they'll appear in the new suite of products, but it's a relatively good guess as to where they'll appear. And as we produce the new versions of these videos, we will post the new lessons online and eventually this lesson will go away as we meld the new features into the new presentation as well. So the various features are labeled with which Java versions they were introduced in. That may be important to you as a developer because you may be required to use a specific version of the Java platform. For example, the current long-term support release is Java 21. Therefore, if you're using Java 21, you won't be able to take advantage of Java 22 features. And some people are still on previous versions of Java as well, such as the long-term support release Java 17, the long-term support release Java 11, or even going all the way back to Java eight as well. So obviously if you are in one of those earlier versions for a project that you're working on, you will not be able to take advantage of some of the later features. As you work your way through this lesson, if you have any questions on these new features, feel free to reach out to me at paul@deitel.com and I'll try to respond to you promptly. You can also check out our deitel.com website for updates on what's going on, and we'll post messages into our various social media channels as well as new content becomes available. Here's the proposed outline for the third edition of this video course. We will be starting with the fundamentals in lessons one through eight. We'll begin by demonstrating how to test drive a Java application. Actually, we'll do that several different ways. Then we'll get into the actual Java programming in lesson two. And in lessons three and four, we'll focus on most but not all of Java's control statements. There are a couple that make sense to cover in later lessons. Next up, we'll take a look at method definitions in Java. Then we'll start getting into data structures with the built-in array data structure and the array list collection class, which is one of many different collections that come built into the Java APIs. And as part of this new version of lesson six, we'll be introducing some functional programming concepts in Java as well, with the Lambda and streams capabilities that were introduced in Java eight. We'll move on to some string character and regular expression processing and we'll finish off the fundamentals section with some files and IO streams capabilities. And as part of that lesson, we'll also get into comma separated value files, which is a popular format for representing data sets nowadays. And also JavaScript object notation, which is the most popular format used to transmit data back and forth over the internet when you have applications that are talking to what are known as web services, which are basically functions that you call on servers around the internet to perform tasks for you and possibly give you back results as well. Next up, we'll move into the object oriented programming portion of the course with custom classes and objects, and we'll then talk about how to create new classes from existing ones via inheritance and the capability of polymorphism, which allows us to process a bunch of objects of related classes as if they're all objects of the superclass in a hierarchy. We will talk more in the next lesson about interfaces, specifically showing you how to create your own custom interfaces and also working with some of the Java APIs interface capabilities as well. And those interface capabilities are critical in hierarchy design nowadays, but they're also critical in all sorts of different areas of Java application development. So it's critical that everyone be familiar with the concepts of interfaces and how to use them as well. We'll finish up the object oriented programming portion with a deeper look at exception handling, which we'll actually introduce initially back in lesson six and we'll use a little bit as well in some of the earlier object oriented programming chapters. Next up, we'll move on to generic programming. We'll take a look at several different generic collections of which array lists are one. The generic collections allow you to specify when you create objects of those collections, the type of elements that they'll store. And we'll also take a look at how to create your own custom generic classes and methods as well. Next up we have a segment on Java FX, graphical user Interfaces, graphics and multimedia, three lesson run on that. Java FX is the modern Java graphical user interface set of capabilities that also includes graphics and multimedia capabilities. It's highly customizable, which is one of the benefits of using it. And so we'll take a look at a number of examples using those capabilities. Unfortunately, Java FX is not built into the Java development kit. So as part of our new and updated before you begin lesson, we'll talk about how to get the Java FX capabilities installed so that you can take advantage of them as part of your Java development. And then finally, we have a number of high-end topics, including a deeper look at functional programming in Java with Lambdas and streams. You'll notice that there's the word streams here, but we also have the word streams back in lesson eight. Those are two different concepts. In the case of lesson eight, it's the concepts of bites or characters being written out of a program or read into a program. In the case of functional programming, the concept of a stream is simply the idea of elements moving their way through a pipeline of operations. And that's just a an entirely different concept. We will have a brand new lesson on generative AI, which of course is super hot right now. We'll show you how to actually programmatically interact with generative Ais in the Java programming language, and we'll actually incorporate a number of concepts from generative AI throughout many of the lessons in the new edition as well. We have an extensive lesson on concurrency and multi-core performance, and this is one of the areas in which there are a bunch of new capabilities. We'll actually have a whole separate new lesson that we will publish before the full new version of the Java Fundamentals course of the concurrency lesson, excuse me, in which we'll introduce those new features so people can start using them right away. We'll have a databases lesson for interacting with databases via JDBC and then back in Java 9 they introduced the Java platform module system, which has had a few changes along the way since then. So we'll be updating that as well. And finally we'll finish off with a lesson on using Java's JShell tool for interactive Java development at the command line. And that's kind of handy not only for learning but also for testing purposes. You can, for example, load up a library into JShell and work with it in a snippet oriented way without having to create full blown applications to test out various features. So it can be quite handy for developers to play around, if you will. As for the new features that you'll see in this lesson, we've broken that down here in a series of slides by the lesson number that the features will be associated with initially based on the current product outline, not the one I just showed you on the previous slide. So for lesson one where we show you how to test drive a Java application, in this lesson, we will show you a new feature that was introduced in Java 11 for executing source files directly via the Java command. And they recently enhanced that feature to support not just single source file programs, but also multiple source file programs. So what's interesting is that the Java command is actually able to read a Java source code file and compile it in memory now and then execute the code directly from memory without ever storing a dot class file on disc. In lesson two's new features, we're going to be taking a look at a new simplified version of the main method that is used to launch a Java application. It's called an instance main method, and there are actually two different ways we can take advantage of this simple new version both inside of an actual named class definition like we've traditionally done in Java since inception, but also we can just define the main method in a file now with no class wrapped around it. And so we'll show you both versions of that. And interestingly, in the version that has no class wrapped around it, it creates an implicitly declared class to wrap around that main method for you. And you can also define other methods in that file as well. So this is about as close as we can get to creating a C programming language style program in the Java programming language. We also have a new feature for multi-line strings called text blocks that we'll take a look at. Those are particularly useful for folks who need to embed large blocks of text into Java source code, things like JavaScript object notation documents for communicating with web services or HTML documents if you're building a web application or maybe SQL queries if you're interacting with databases, for example. As for the features related to lesson four on the first control statements lesson, we have a new feature called string templates. And the reason I associated this with lesson four is this is the lesson where we first do not only formatted output, but specifically a little bit of floating point number formatting as well. With string templates, we have a new feature that allows you to plug values directly into placeholders within a string, literal or a text block as well. So we'll introduce what are known as template processors that can either simply plug something in or apply formatting as well. There's two different template processors that we'll demonstrate there. For lesson five, we'll take a look at a feature that was introduced in Java 14 called Switch Expressions. It's a new, more compact way to represent the concept of a switch statement, but it's also more powerful. As you'll see over a a series of examples in this what's New lesson, there's actually some pattern matching capabilities that have been added to the Java programming language and those pattern matching capabilities make the switch concept much more powerful now than it used to be in Java. From the inception of Java, we were able to create switches that supported integer constants and enumerated constants and strings as well, which was added a little bit later. But now with the various pattern matching capabilities that they've been adding in versions of Java after version 14, we actually have the capability now to test any kind of object in a switch controlling expression with these new switch expressions and test that against the various cases. Also, cases are no longer restricted to just a single constant value. You can actually have comma delimited lists of values in cases as well. So we'll build up the set of switch capabilities over several examples throughout this What's New lesson. With regard to lesson six on methods, we have a couple of new features that we'll introduce here. The methods lesson is where we introduce random number generation in our book and videos. And what we've done for this part of the demonstration is we've actually reimplemented one of the examples from lesson six. It simulates a die rolling game from casinos around the world. And as part of that, we're actually going to demonstrate two different new features. From Java 16, we have a concept called records. Some languages refer to these as data classes. They are classes, special classes that enable you to house data and access that data. And objects of these classes are immutable, so they're meant specifically for the purpose of grouping together a bunch of data items into an object and making those data items conveniently accessible. And one of the new features associated with records that came later is the ability to use records in the context of those switch expressions that I was talking about in the previous slide. So we'll talk more about records in later examples as well, but we'll use a record class to represent a pair of randomly rolled dice. And for the random number generation, we'll use a feature from Java 17, which is from their enhanced Pseudo-Random number generators. There's a new class called random generator that can give you a default Pseudo-Random number generator, but it also supports a total of 13 random number generation algorithms that you can choose from as well. So we'll give you a reference to the doc page where you can learn more about those algorithms. When we do talk about records, we're gonna see that records auto generate certain kind of boilerplate code that you need to be able to initialize an object to be able to get the values out of an object. They'll create an automated string representation for an object and some other methods as well that we'll talk about in later examples. For lesson seven on arrays and array lists, we have a Java 10 feature that we'll talk about called local variable type inference, which is basically where when you declare a local variable and immediately initialize it inside the body of a method, you can let the compiler figure out the variables data type from its initializer. So whatever's on the right side of the equal sign, the compiler knows what that is and can use that to help declare the variable for you. And that's a new keyword called var V-A-R, which is short for variable that will let the compiler do that work for you. With respect to lesson eight, we'll go back and talk more about the concepts of records. One of the interesting features of records is the ability to create a short form of constructor where all you specify is your validation code. And if the data items that you pass into the constructor for a record are all valid, it will automatically handle the assignment of the arguments to the constructor into the instance variables for the record object, which is kind of a cool little feature. So we'll demonstrate that and we'll talk more about all the different capabilities that are auto generated for you as part of record classes. We'll also take a look at features from Java 21, the pattern matching capabilities for switch were introduced here. And along with those are something called record patterns. So we're going to talk a lot about records in this lesson. And when we look at these features, we're going to see that this pattern matching switch expression is able to look at the type of objects and if they are record objects, we can also automatically decompose them into individual variables from the record data types. So for convenient access to the data members or the instance variables I should say, we have these things called record patterns. They work well with switch expressions, but they can also be used with what is known as the pattern matching instance of operator also. Java 22 introduced something called unnamed variables and patterns. And this is for scenarios where, for example, a variable name may be required, but you don't need to use the variable in your code. They give a new feature, which is the underscore character that can be used to specify a placeholder for a variable name that is not used in the code. So for example, if you're doing a try-catch statement and your catch handler for an exception doesn't need to interact with the exception object, you can specify instead of a variable name, the underscore character, and that's an unnamed variable to allow the syntax to work correctly for that statement. You can also use those in records if, for example, you were decomposing a record object that had lots of fields in it, but you only needed to use certain fields in a switch expression, you can use unnamed variables to indicate the other fields that you don't intend to take advantage of. With respect to chapter nine, we have an interesting new preview feature called Statements Before Super. With respect to constructors, since the inception of Java, it has always been the case that when a constructor for a subclass type gets called, the very first thing it must do in its body is either call another constructor in the same class, which in turn usually would have to call the superclass constructor, or the subclass constructor must immediately invoke the super classes constructor. And that means that you may wind up doing some additional work that is unnecessary because when you get back to the subclass constructor, which is where you would do validation of additional arguments that are specific to the subclass, if there's an invalid argument, generally you would throw an exception at that point. And that means that all the work you've done previously in Superclass constructors was unnecessary in the first place. So they're previewing a feature that allows us to put validation code in a subclass constructor before we write the call to super or in the case where you're calling another constructor of the same class to do some shared code before the call to this. And by doing that, we can help improve a little bit the performance of our initialization in cases where exceptions are going to get thrown because of invalid data. For features related to lesson 10 on object-oriented programming polymorphism and interfaces, we have something called the pattern matching version of the instance of operator. So as part of this example, we'll actually do a re-architecting of the employee hierarchy that's currently presented in that polymorphism lesson in these live lessons videos. And we'll talk a little bit, as part of that example about programming to an interface rather than doing implementation inheritance. So first we'll take a look at a new hierarchy, and then we'll use that new hierarchy with this new version of the instance of operator. And we'll also edit that hierarchy, or I should say modify that hierarchy with a new feature called sealed classes, which is really sealed classes and interfaces. And what these sealed classes and interfaces enable you to do as a hierarchy designer is gain complete control over your hierarchy. Because when you define a sealed super class, part of defining it is to actually name the explicit subclasses that are allowed. And when you define a sealed interface, part of defining it is to define a list of explicit classes that are allowed to implement that interface. So you basically have a closed set of types that you're creating with a sealed superclass or a sealed interface, and that gives you complete control over those types. And there are no surprises in applications that use sealed hierarchies where another programmer could come along and extend your hierarchy with an unknown type that could cause problems in your application because that simply is not allowed when you're using sealed hierarchies. And then finally, to finish off this what's New lesson, we're going to jump to the generic collections feature called Sequenced Collections. Interestingly, it turns out that there's a bunch of types of collections in Java that can be indexed by position number. Those are sequenced collections. And also, interestingly, although they all support things like being able to add an element at the beginning or end of the collection and remove an element from the beginning or end of a collection or get the element from the beginning or end of a collection, they use different method names across the different collection classes. So they've added some new interfaces to Java 21 that unify the method naming across those different collection classes, thus making those collections easier to use and learn for people new to the language because they're now going to be more consistent with one another. And also, as part of the sequenced collection capabilities, they've added a new method to these interfaces called Reversed, which allows you to iterate backwards through those collections as well. Just as a reminder, if you have any questions as you work your way through these videos, you can once again reach out to me at paul@deitel.com and on all of these sites, we'll be announcing the new content as it becomes available. And you may notice if you've been following along with the Java releases, that there are other concepts that we are not covering in this What's New in Java lesson. For example, there's a bunch of new stuff going on in the areas of concurrency and parallelism. I'm going to have a whole separate new lesson on that set of concepts that I'm already working on right now, and we will post that here as well as soon as it becomes available.